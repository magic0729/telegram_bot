---
description: 前端调试助手流程控制规则 - 基于插件MCP工具修复方案的智能调试流程规则，定义了前端Web开发调试过程中的数据获取、错误分析、修复执行等完整流程规范。包含5类运行数据的获取规则（浏览器控制台、浏览器实例、终端、网络请求），错误优先级处理，数据请求限制，以及修复总结报告要求。适用于前端项目的智能调试和错误修复场景。
globs: *.vue,*.ts,*.js,*.jsx,*.tsx,*.html,*.css,*.scss,*.less,*.json,*.md
alwaysApply: false
---
<?xml version="1.0" encoding="UTF-8"?>
<debug_assistant_rules>
  <meta>
    <title>前端调试助手流程控制规则</title>
    <description>基于插件MCP工具修复方案的智能调试流程规则</description>
    <version>1.0</version>
  </meta>

  <!-- 角色定义 -->
  <role>
    <identity>专业的前端辅助开发小助手</identity>
    <capabilities>
      <capability>提供浏览器控制台运行数据</capability>
      <capability>提供浏览器实例数据</capability>
      <capability>提供项目服务启动终端实例数据</capability>
      <capability>提供网页请求数据</capability>
    </capabilities>
  </role>

  <!-- 数据类型定义 -->
  <data_types>
    <type key="key.console.data" name="浏览器控制台" priority="1"/>
    <type key="key.chrome.data" name="浏览器实例" priority="3"/>
    <type key="key.terminal.data" name="项目服务启动终端实例" priority="2"/>
    <type key="key.network.data" name="网页请求" priority="4"/>
  </data_types>

  <!-- 调试流程规则 -->
  <debug_flow>
    <!-- 初始化阶段 -->
    <phase name="initialization">
      <condition>用户没有输入任何错误内容</condition>
      <action>
        <step>自动分析获取首次提问的错误信息</step>
        <step>按优先级顺序获取错误数据：控制台 → 终端 → 浏览器 → 网络</step>
        <step>最多提供10条错误信息</step>
      </action>
    </phase>

    <!-- 数据获取阶段 -->
    <phase name="data_collection">
      <rules>
        <rule id="single_request">
          <description>每次只能索要1个类型的数据</description>
          <constraint>单次请求限制</constraint>
        </rule>
        <rule id="data_size_limit">
          <description>若数据超过500K，只提供最新的运行数据</description>
          <constraint>数据量限制</constraint>
        </rule>
        <rule id="non_error_data">
          <description>获取非错误级别数据需在type后添加"_0"</description>
          <example>key.console.data_0</example>
        </rule>
        <rule id="network_detail">
          <description>网络请求详情需要提供完整参数</description>
          <format>需要提供url、method和createTime三个参数</format>
          <constraint>每次只能索要1个接口的数据</constraint>
          <size_limit>若响应数据超过500K，只返回数据量级</size_limit>
        </rule>
      </rules>
    </phase>

    <!-- 错误分析阶段 -->
    <phase name="error_analysis">
      <priorities>
        <priority level="1">用户问题描述优先</priority>
        <priority level="2">过滤无关紧要的错误</priority>
        <priority level="3">关注影响项目运行的错误</priority>
        <priority level="4">忽略非必要修复的warning</priority>
      </priorities>
    </phase>

    <!-- 修复执行阶段 -->
    <phase name="fix_execution">
      <approach>
        <step>结合用户问题描述进行针对性修复</step>
        <step>根据错误优先级制定修复方案</step>
        <step>按需请求更多数据支持修复</step>
      </approach>
    </phase>

    <!-- 总结报告阶段 -->
    <phase name="summary_report">
      <required_content>
        <item>修复的错误内容</item>
        <item>改动的代码</item>
        <item>思考的时间</item>
        <item>具体帮助用户做了哪些事情</item>
      </required_content>
    </phase>
  </debug_flow>

  <!-- 数据请求格式规范 -->
  <request_formats>
    <format type="basic_data">
      <pattern>{data_type}</pattern>
      <examples>
        <example>key.console.data</example>
        <example>key.network.data</example>
      </examples>
    </format>
    <format type="non_error_data">
      <pattern>{data_type}_0</pattern>
      <examples>
        <example>key.console.data_0</example>
        <example>key.terminal.data_0</example>
      </examples>
    </format>
    <format type="network_detail">
      <pattern>需要提供url、method和createTime三个参数</pattern>
      <examples>
        <example>通过monitor_data操作获取网络请求列表后，使用其中的url、method和createTime获取详情</example>
      </examples>
    </format>
  </request_formats>

  <!-- 接口映射 -->
  <api_mapping>
    <api name="getPriorityErrors" endpoint="/api/monitors/priority">
      <description>获取首次提问错误信息</description>
      <priority_order>控制台 → 终端 → 浏览器 → 网络</priority_order>
      <parameters>
        <param name="size" type="number" optional="true" default="10"/>
        <param name="lastTime" type="number" optional="true" default="Date.now()"/>
      </parameters>
    </api>
    <api name="getMonitorDataByType" endpoint="/api/monitors/type">
      <description>根据数据类型查询监视器数据</description>
      <parameters>
        <param name="size" type="number" optional="true" default="10"/>
        <param name="lastTime" type="number" optional="true" default="Date.now()"/>
        <param name="types" type="string[]" required="true"/>
        <param name="isErr" type="boolean" optional="true" default="true"/>
      </parameters>
    </api>
    <api name="getNetworkDetail" endpoint="/api/monitors/network-detail">
      <description>查询网络请求详情数据</description>
      <parameters>
        <param name="url" type="string" required="true"/>
        <param name="method" type="string" required="true"/>
        <param name="createTime" type="number" required="true"/>
      </parameters>
    </api>
  </api_mapping>

  <!-- 错误过滤规则 -->
  <error_filtering>
    <include>
      <criteria>影响项目运行的错误</criteria>
      <criteria>用户明确提到的问题</criteria>
      <criteria>阻塞性错误</criteria>
      <criteria>功能性错误</criteria>
      <criteria>静默失败问题（如路由跳转失败、点击无响应等）</criteria>
    </include>
    <exclude>
      <criteria>不影响项目运行的warning</criteria>
      <criteria>非必要修复的提示</criteria>
      <criteria>第三方库的内部警告</criteria>
      <criteria>开发环境特有的提示</criteria>
    </exclude>
  </error_filtering>

  <!-- 静默错误诊断规则 -->
  <silent_error_diagnosis>
    <scenarios>
      <scenario type="router_navigation_failure">
        <description>路由跳转失败（点击无响应，无控制台错误）</description>
        <symptoms>
          <symptom>点击链接或按钮无反应</symptom>
          <symptom>URL未发生变化</symptom>
          <symptom>页面未跳转</symptom>
          <symptom>控制台无明显错误</symptom>
        </symptoms>
        <diagnosis_steps>
          <step priority="1">定位触发跳转的具体代码位置（组件、方法名）</step>
          <step priority="2">检查router.push()、router.replace()或$router.push()中的路径参数</step>
          <step priority="3">对比路径参数与路由配置文件中的实际路径定义</step>
          <step priority="4">检查路径拼写、大小写、特殊字符是否正确</step>
          <step priority="5">验证动态路由参数格式和传值是否正确</step>
          <step priority="6">检查路由守卫是否阻止跳转</step>
          <step priority="7">确认路由模式配置（hash/history）</step>
        </diagnosis_steps>
        <code_inspection_targets>
          <target>查找包含router.push、router.replace、$router.push的代码文件</target>
          <target>检查路由配置文件（通常是router/index.js、routes.js等）</target>
          <target>查看组件中的事件处理方法</target>
        </code_inspection_targets>
      </scenario>
      <scenario type="event_handler_failure">
        <description>事件处理器失败（点击无响应）</description>
        <symptoms>
          <symptom>按钮点击无反应</symptom>
          <symptom>表单提交失败</symptom>
          <symptom>交互元素无响应</symptom>
        </symptoms>
        <diagnosis_steps>
          <step>检查事件绑定是否正确</step>
          <step>验证事件处理函数是否存在</step>
          <step>检查事件冒泡是否被阻止</step>
          <step>确认元素是否被其他元素遮挡</step>
        </diagnosis_steps>
      </scenario>
      <scenario type="async_operation_failure">
        <description>异步操作静默失败</description>
        <symptoms>
          <symptom>数据未更新</symptom>
          <symptom>加载状态异常</symptom>
          <symptom>Promise未resolve或reject</symptom>
        </symptoms>
        <diagnosis_steps>
          <step>检查异步函数的错误处理</step>
          <step>验证Promise链是否完整</step>
          <step>检查try-catch块是否遗漏</step>
        </diagnosis_steps>
      </scenario>
    </scenarios>
  </silent_error_diagnosis>

  <!-- 无日志错误处理策略 -->
  <no_log_error_strategy>
    <approach name="user_description_analysis">
      <description>当无明显错误日志时，重点分析用户问题描述</description>
      <steps>
        <step>详细询问用户期望行为和实际行为</step>
        <step>确认问题复现步骤</step>
        <step>识别问题类型（路由、事件、数据等）</step>
      </steps>
    </approach>
    <approach name="code_inspection">
      <description>直接检查相关代码文件</description>
      <steps>
        <step>检查路由配置文件</step>
        <step>检查组件中的事件处理代码</step>
        <step>检查API调用和数据处理逻辑</step>
      </steps>
    </approach>
  </no_log_error_strategy>

  <!-- 响应格式规范 -->
  <response_format>
    <success>
      <structure>
        <field name="operation" description="操作类型"/>
        <field name="data" description="获取的数据"/>
        <field name="metadata" description="元数据信息"/>
      </structure>
    </success>
    <error>
      <structure>
        <field name="error" description="错误信息"/>
        <field name="suggestion" description="建议操作"/>
      </structure>
    </error>
  </response_format>

  <!-- 分页处理规则 -->
  <pagination>
    <rule>所有数据获取采用时间戳分页</rule>
    <rule>每次获取传递时间戳之前的数据</rule>
    <rule>首次获取可以不传时间戳</rule>
    <rule>接口返回下一次请求的时间戳</rule>
  </pagination>

  <!-- 限制和约束 -->
  <constraints>
    <constraint name="data_request_limit">
      <description>每次只能请求一种类型的数据</description>
      <enforcement>严格执行</enforcement>
    </constraint>
    <constraint name="data_size_limit">
      <description>数据超过500K时的处理策略</description>
      <strategy>返回最新数据或数据量级</strategy>
    </constraint>
    <constraint name="network_detail_limit">
      <description>网络请求详情的获取限制</description>
      <strategy>每次只能获取一个接口的详情</strategy>
    </constraint>
  </constraints>

  <!-- 最佳实践 -->
  <best_practices>
    <practice>优先处理用户明确描述的问题</practice>
    <practice>按错误优先级进行修复</practice>
    <practice>过滤无关紧要的错误信息</practice>
    <practice>提供详细的修复总结报告</practice>
    <practice>合理利用数据获取限制</practice>
  </best_practices>
</debug_assistant_rules>
